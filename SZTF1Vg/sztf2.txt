Öröklődés:
ősosztály <- leszármazott osztály
Polimorfizmus: bármely leszármazott osztály referenciával lehet hívítkozni az objektumra
lefele specializáció, felfele generalizáció
VMT: virtuális metódus tábla
mezők (adattagok, tulajdonságok), metódusok
Aggregáció: tartalmazási kapcsolat
Kompozíció: szimbiózis, egybe működik csak, erős kapcsolat

Interfész: T-vel, T ősével, T interfészeivel, T ős interfészeivel, interfész őseivel (kiterjesztés)
explicit, implicit: IRepülnitud.Repül(), IVizsga.Repül()

Eseménykezelés: callback/visszahívás, származtatással, interfésszel, event/delegált
öröklés: virtual Gomb.EseményKezelő() <- override HelloGomb.EseményKezelő()
interface: IKecskePulzusFigyelő kpe

Kivételkezelés:
Tesztelés:
Statikus: kódelleneőrzés, formai, tartalmi ellenőrzés
Dinamikus: fekete doboz, fehér doboz 
Hibakeresés: a tesztelés során feltárt hibák helyének meghatározása
indukciós, dedukciós módszer


Brute force / Nyers erő:
függvény HátizsákBF
    OPT <- [hamis, hamis, hamis, ... ,hamis]
    ciklus i <- 1-től 2^N-1-ig
        ciklus j <- 1-től N-1-ig
            K[j] <- Li/2^jL mod 2 = 1
        ciklus vége
        ha (Összsúly(K) <= Wmax) ^ (ÖsszÉrték(K) > ÖsszÉrték(OPT)) akkor
            OPT <- K
        elágazás vége
    ciklus vége
    ÖsszÉrték(OPT)
függvény vége


Osz meg és uralkods:
függvény LegjobbRészMegoldás(t, h)
    ha (t = 0) ˅ (h = 0) akkor
        vissza 0
    különben
        Pnem <- LegjobbRészMegoldás(t-1, h)
        ha h >= wt akkor
            Pigen <- pt + LegjobbRészMegoldás(t-1, h-wt)
            Popt <- max(Pigen, Pnem)
        különben
            Popt <- Pnem
        elágazás vége
        vissza Popt
    elágazás vége
függvény vége

üggvény HátizsákDnC
    vissza LegjobbRészMegoldás(N, Wmax)
függvény vége


Feljegyzéses / Memoization:
függvény LegjobbRészMegoldás(t, h)
    ha (t = 0) v (h = 0) akkor
        vissza 0
    különben
        ha RészMegoldásTárolóbanKeres([t, h]) != 0 akkor
            vissza RészMegoldásTárolóbanKeres([t, h])
        különben
            Pnem <- LegjobbRészMegoldás(t-1, h)
            ha h >= wt akkor
                Pigen <- pt + LegjobbRészMegoldás(t-1, h-wt)
                Popt <- max(Pigen, Pnem)
            különben
                Popt <- Pnem
            elágazás vége
            RészMegoldásTárolóbaFeljegyez([t, h], Popt)
            vissza Popt
        elágazás vége
    elágazás vége
függvény vége

függvény HátizsákMemo
    vissza LegjobbRészMegoldás(N, Wmax)
függvény vége


Dinamikus programozás:
függvény HátizsákDP
    ciklus t <- 0-tól N-ig
        F[t,0] <- 0
    ciklus vége
    ciklus h <- 1-től Wmax-ig
        F[0,h] <- 0
    ciklus vége
    ciklus t <- 1-től N-ig
        ciklus h <- 1-től Wmax-ig
            ha h >= wt akkor
                F[t,h] <- max(F[t-1,h], F[t-1,h-wt] + pt)
            különben
                F[t,h] <- F[t-1,h]
            elágazás vége
        ciklus vége
    ciklus vége
    vissza F[N,Wmax]
függvény vége

függvény HátizsákDPEredmény(F)
    OPT <- [hamis,hamis, ... ,hamis]
    t <- N
    h <- Wmax
    ciklus amíg (t > 0) ^ (h > 0)
        ha F[t,h] != F[t-1,h] akkor
            OPT[t] <- igaz
            h <- h - wj
        elágazás vége
        t <- t - 1
    ciklus vége
    vissza OPT
függvény vége


Mohó algoritmus:
függvény HátizsákMohó
    TárgyakRendezése(w, p)
    OPT <- [hamis,hamis, ... ,hamis]
    t <- 1
    ciklus amíg (ÖsszSúly(OPT) < Wmax) ^ (t <= N)
        ha ÖsszSúly(OPT) + wt <= Wmax akkor
            OPT[t] <- igaz
        elágazás vége
        t <- t + 1
    ciklus vége
    vissza ÖsszÉrték(OPT)
függvény vége


Visszalépéses keresés/Backtrack search/BST:
eljárás VisszalépésesKeresés(szint, címsz. E, címsz. van)
    i <- 0
    ciklus amíg !van ^ i < Mszint
        i <- i + 1
        ha Ft(szint, Rszint,i) akkor
            ha Fk(szint, Rszint,i, E) akkor
                Eszint <- Rszint,i
                ha szint = N akkor
                    van <- igaz
                    MIND <- MIND U E
                különben
                    VisszalépésesKeresés(szint + 1, E, van)
                elágazás vége
            elágazás vége
        elágazás vége
    ciklus vége
eljárás vége

van <- hamis
VisszalépésesKeresés(1, E, van)


Szétválasztás és korlátozás/Branch and bound:
függvény Fb(szint, E)
    pfk <- 0
    ciklus i <- szint + 1-től N-ig
        ha ÖsszSúly(E) + wi < Wmax akkor
            pfk <- pfk + pi
        elágazás vége
    ciklus vége
    vissza pfk
függvény vége

eljárás BB(szint, címsz. E, címsz. OPT)
    ciklus i <- 0-tól 1-ig
        E[szint] <- (i = 0)
        ha Fk(szint, E) akkor
            ha szint = N akkor
                ha ÖsszÉrték(E) > ÖsszÉrték(OPT) akkor
                    OPT <- E
                elágazás vége
            különben
                ha ÖsszÉrték(E) + Fb(szint,E) > ÖsszÉrték(OPT) akkor
                    BB(szint + 1, E, OPT)
                elágazás vége
            elágazás vége
        elágazás vége
    ciklus vége
eljárás vége


Láncoltlisták:


